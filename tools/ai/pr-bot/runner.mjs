import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { spawn } from 'node:child_process';
import { execSync } from 'node:child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '../../..');

const prompt = process.argv.slice(2).join(' ').trim();
if (!prompt) {
  console.error('[ai-pr-bot] missing prompt input');
  process.exit(1);
}

// Parse “command” from prompt body, e.g.:
//   scaffold:fixtures-dto league=39 limit=2
const cmdLine = (prompt.match(/scaffold:[^\n]+/i)?.[0] || '').trim();
const cmd = cmdLine.split(/\s+/)[0].toLowerCase();
const kv = Object.fromEntries(
  cmdLine
    .split(/\s+/)
    .slice(1)
    .map(pair => {
      const [k, v] = pair.split('=');
      return [k, v];
    })
);

// Util: start MCP server (uses built dist file)
function startMcp() {
  const serverPath = path.join(repoRoot, 'packages', 'mcp-football', 'dist', 'index.js');
  const proc = spawn('node', [serverPath], { stdio: ['pipe', 'pipe', 'inherit'] });
  proc.stdout.setEncoding('utf8');
  return proc;
}

// Util: send one JSON-RPC message and wait for a response
function rpc(proc, method, params) {
  const id = Math.random().toString(36).slice(2);
  const msg = JSON.stringify({ jsonrpc: '2.0', id, method, params }) + '\n';
  proc.stdin.write(msg);
  return new Promise((resolve, reject) => {
    const onData = (buf) => {
      const lines = String(buf).split('\n');
      for (const line of lines) {
        const s = line.trim();
        if (!s || (s[0] !== '{' && s[0] !== '[')) continue;
        try {
          const resp = JSON.parse(s);
          if (resp.id === id || resp.result || resp.error) {
            proc.stdout.off('data', onData);
            resolve(resp);
            return;
          }
        } catch {
          // ignore non-json
        }
      }
    };
    proc.stdout.on('data', onData);
    setTimeout(() => reject(new Error('RPC timeout')), 15000);
  });
}

// Template: generate minimal DTO + test from MCP data
function genDtoCode(items, leagueId) {
  return `// Auto-generated by IssueOps AI bot using MCP fixtures_get
export type Team = { id: number; name: string };
export type Fixture = {
  id: number;
  date: string;
  status: string;
  home: Team;
  away: Team;
};

export type FixturesResponse = {
  leagueId: number;
  items: Fixture[];
};

export const sampleFixtures_${leagueId}: FixturesResponse = {
  leagueId: ${leagueId},
  items: [
${items
    .map((it) => {
      const f = it.fixture || it;
      const status = (f.status?.short || 'NS');
      const home = it.teams?.home || { id: 0, name: 'Home' };
      const away = it.teams?.away || { id: 0, name: 'Away' };
      return `    { id: ${f.id}, date: "${f.date}", status: "${status}", home: { id: ${home.id}, name: "${home.name}" }, away: { id: ${away.id}, name: "${away.name}" } }`;
    })
    .join(',\n')}
  ]
};
`;
}

function genDtoTest(slug, leagueId) {
  return `import { describe, it, expect } from 'vitest';
import { sampleFixtures_${leagueId} } from './${slug}';

describe('${slug}', () => {
  it('has items', () => {
    expect(Array.isArray(sampleFixtures_${leagueId}.items)).toBe(true);
    expect(sampleFixtures_${leagueId}.leagueId).toBe(${leagueId});
  });
});
`;
}

// Fallback: simple identity stub (old behavior)
async function writeStub(promptText) {
  const slug = promptText
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '')
    .slice(0, 40) || 'task';
  const name = slug.replace(/-/g, '_');
  const file = path.join(repoRoot, 'packages', 'api', 'src', `${slug}.ts`);
  const test = path.join(repoRoot, 'packages', 'api', 'src', `${slug}.test.ts`);
  const code = `export function ${name}(x: number) { return x; }\n`;
  const spec = `import { describe, it, expect } from 'vitest';
import { ${name} } from './${slug}';
describe('${slug}', () => { it('returns input', () => { expect(${name}(42)).toBe(42); }); });\n`;
  await fs.mkdir(path.dirname(file), { recursive: true });
  await fs.writeFile(file, code);
  await fs.writeFile(test, spec);
  execSync(`git add ${file} ${test}`, { stdio: 'inherit' });
  console.log(`[ai-pr-bot] prepared stub ${file} and ${test}`);
}

// Main: handle known command
(async () => {
  if (cmd === 'scaffold:fixtures-dto') {
    const leagueId = Number(kv.league || kv.leagueId || kv.league_id || 39);
    const limit = Number(kv.limit || 1);

    // Start MCP and call fixtures_get
    const proc = startMcp();
    try {
      // list tools (optional)
      await rpc(proc, 'tools/list', {});
      const res = await rpc(proc, 'tools/call', { name: 'fixtures_get', arguments: { leagueId, limit } });
      const items = res?.result?.content?.[0]?.json?.items || [];
      if (!Array.isArray(items) || items.length === 0) {
        console.warn('[ai-pr-bot] MCP returned no items; falling back to stub');
        await writeStub(prompt);
        proc.kill();
        return;
      }
      // write DTO + test
      const slug = `fixtures-${leagueId}`;
      const file = path.join(repoRoot, 'packages', 'api', 'src', `${slug}.ts`);
      const test = path.join(repoRoot, 'packages', 'api', 'src', `${slug}.test.ts`);
      await fs.mkdir(path.dirname(file), { recursive: true });
      await fs.writeFile(file, genDtoCode(items, leagueId));
      await fs.writeFile(test, genDtoTest(slug, leagueId));
      execSync(`git add ${file} ${test}`, { stdio: 'inherit' });
      console.log(`[ai-pr-bot] prepared ${file} and ${test} from MCP data`);
    } finally {
      proc.kill();
    }
  } else {
    // Unknown command → legacy stub
    await writeStub(prompt);
  }
})();