import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { spawn } from 'node:child_process';
import { execSync } from 'node:child_process';
import { request } from 'node:http';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '../../..');

const ALLOW_DIR = path.join(repoRoot, 'packages', 'api', 'src');
const MAX_FILES = 6;
const MAX_BYTES = 64 * 1024;

const prompt = process.argv.slice(2).join(' ').trim();
if (!prompt) {
  console.error('[ai-pr-bot] missing prompt input');
  process.exit(1);
}

// Parse “command” from prompt body, e.g.:
//   scaffold:fixtures-dto league=39 limit=2
const cmdLine = (prompt.match(/scaffold:[^\n]+/i)?.[0] || '').trim();
const cmd = cmdLine.split(/\s+/)[0].toLowerCase();
const kv = Object.fromEntries(
  cmdLine
    .split(/\s+/)
    .slice(1)
    .map(pair => {
      const [k, v] = pair.split('=');
      return [k, v];
    })
);

function postJson(url, payload) {
  return new Promise((resolve, reject) => {
    try {
      const u = new URL(url);
      const data = Buffer.from(JSON.stringify(payload));
      const req = request(
        {
          hostname: u.hostname,
          port: u.port || (u.protocol === 'https:' ? 443 : 80),
          path: u.pathname,
          method: 'POST',
          protocol: u.protocol,
          headers: {
            'content-type': 'application/json',
            'content-length': data.length,
          },
        },
        (res) => {
          let body = '';
          res.setEncoding('utf8');
          res.on('data', (c) => (body += c));
          res.on('end', () => {
            try {
              resolve({ status: res.statusCode, json: JSON.parse(body || '{}') });
            } catch (e) {
              reject(new Error(`Bad JSON from AI: ${body}`));
            }
          });
        }
      );
      req.on('error', reject);
      req.write(data);
      req.end();
    } catch (e) {
      reject(e);
    }
  });
}

// Util: start MCP server (uses built dist file)
function startMcp() {
  const serverPath = path.join(repoRoot, 'packages', 'mcp-football', 'dist', 'index.js');
  const proc = spawn('node', [serverPath], { stdio: ['pipe', 'pipe', 'inherit'] });
  proc.stdout.setEncoding('utf8');
  return proc;
}

// Util: send one JSON-RPC message and wait for a response
function rpc(proc, method, params) {
  const id = Math.random().toString(36).slice(2);
  const msg = JSON.stringify({ jsonrpc: '2.0', id, method, params }) + '\n';
  proc.stdin.write(msg);
  return new Promise((resolve, reject) => {
    const onData = (buf) => {
      const lines = String(buf).split('\n');
      for (const line of lines) {
        const s = line.trim();
        if (!s || (s[0] !== '{' && s[0] !== '[')) continue;
        try {
          const resp = JSON.parse(s);
          if (resp.id === id || resp.result || resp.error) {
            proc.stdout.off('data', onData);
            resolve(resp);
            return;
          }
        } catch {
          // ignore non-json
        }
      }
    };
    proc.stdout.on('data', onData);
    setTimeout(() => reject(new Error('RPC timeout')), 15000);
  });
}

async function applyFiles(files) {
  if (!Array.isArray(files) || files.length === 0) throw new Error('AI returned no files');
  if (files.length > MAX_FILES) throw new Error(`Too many files: ${files.length}`);
  let total = 0;
  for (const f of files) {
    if (!f?.path || typeof f?.content !== 'string') throw new Error('Invalid file descriptor');
    const abs = path.resolve(repoRoot, f.path);
    if (!abs.startsWith(ALLOW_DIR)) throw new Error(`Write outside allowlist: ${f.path}`);
    total += Buffer.byteLength(f.content, 'utf8');
    if (total > MAX_BYTES) throw new Error('AI output too large');
    await fs.mkdir(path.dirname(abs), { recursive: true });
    await fs.writeFile(abs, f.content);
    execSync(`git add ${abs}`, { stdio: 'inherit' });
  }
}

// Template: generate minimal DTO + test from MCP data
function genDtoCode(items, leagueId) {
  return `// Auto-generated by IssueOps AI bot using MCP fixtures_get
export type Team = { id: number; name: string };
export type Fixture = {
  id: number;
  date: string;
  status: string;
  home: Team;
  away: Team;
};

export type FixturesResponse = {
  leagueId: number;
  items: Fixture[];
};

export const sampleFixtures_${leagueId}: FixturesResponse = {
  leagueId: ${leagueId},
  items: [
${items
    .map((it) => {
      const f = it.fixture || it;
      const status = (f.status?.short || 'NS');
      const home = it.teams?.home || { id: 0, name: 'Home' };
      const away = it.teams?.away || { id: 0, name: 'Away' };
      return `    { id: ${f.id}, date: "${f.date}", status: "${status}", home: { id: ${home.id}, name: "${home.name}" }, away: { id: ${away.id}, name: "${away.name}" } }`;
    })
    .join(',\n')}
  ]
};
`;
}

function genDtoTest(slug, leagueId) {
  return `import { describe, it, expect } from 'vitest';
import { sampleFixtures_${leagueId} } from './${slug}';

describe('${slug}', () => {
  it('has items', () => {
    expect(Array.isArray(sampleFixtures_${leagueId}.items)).toBe(true);
    expect(sampleFixtures_${leagueId}.leagueId).toBe(${leagueId});
  });
});
`;
}

// Fallback: simple identity stub (old behavior)
async function writeStub(promptText) {
  const slug = promptText
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '')
    .slice(0, 40) || 'task';
  const name = slug.replace(/-/g, '_');
  const file = path.join(repoRoot, 'packages', 'api', 'src', `${slug}.ts`);
  const test = path.join(repoRoot, 'packages', 'api', 'src', `${slug}.test.ts`);
  const code = `export function ${name}(x: number) { return x; }\n`;
  const spec = `import { describe, it, expect } from 'vitest';
import { ${name} } from './${slug}';
describe('${slug}', () => { it('returns input', () => { expect(${name}(42)).toBe(42); }); });\n`;
  await fs.mkdir(path.dirname(file), { recursive: true });
  await fs.writeFile(file, code);
  await fs.writeFile(test, spec);
  execSync(`git add ${file} ${test}`, { stdio: 'inherit' });
  console.log(`[ai-pr-bot] prepared stub ${file} and ${test}`);
}

// Main: handle known command
(async () => {
  if (cmd === 'scaffold:fixtures-dto') {
    const leagueId = Number(kv.league || kv.leagueId || kv.league_id || 39);
    const limit = Number(kv.limit || 1);

    // Start MCP and call fixtures_get
    const proc = startMcp();
    try {
      // list tools (optional)
      await rpc(proc, 'tools/list', {});
      const res = await rpc(proc, 'tools/call', { name: 'fixtures_get', arguments: { leagueId, limit } });
      const items = res?.result?.content?.[0]?.json?.items || [];
      if (!Array.isArray(items) || items.length === 0) {
        console.warn('[ai-pr-bot] MCP returned no items; falling back to stub');
        await writeStub(prompt);
        proc.kill();
        return;
      }
      // If an AI endpoint is configured, let it generate files first
      const AI_URL = process.env.AI_GENERATE_URL; // e.g., http://127.0.0.1:8787/generate
      if (AI_URL) {
        const context = {
          repo: 'insightfc',
          package: '@app/api',
          mcp: { items, leagueId },
          task: 'scaffold fixtures dto + test'
        };
        try {
          const ai = await postJson(AI_URL, { prompt, context });
          if ((ai.status || 500) >= 400) throw new Error(`AI status ${ai.status}`);
          await applyFiles(ai.json.files);
          console.log(`[ai-pr-bot] applied ${ai.json.files.length} file(s) from AI`);
          return; // files are staged; PR creator step will pick them up
        } catch (e) {
          console.warn('[ai-pr-bot] AI call failed, falling back to deterministic DTO:', String(e?.message || e));
          // fall through to deterministic generation below
        }
      }
      // write DTO + test
      const slug = `fixtures-${leagueId}`;
      const file = path.join(repoRoot, 'packages', 'api', 'src', `${slug}.ts`);
      const test = path.join(repoRoot, 'packages', 'api', 'src', `${slug}.test.ts`);
      await fs.mkdir(path.dirname(file), { recursive: true });
      await fs.writeFile(file, genDtoCode(items, leagueId));
      await fs.writeFile(test, genDtoTest(slug, leagueId));
      execSync(`git add ${file} ${test}`, { stdio: 'inherit' });
      console.log(`[ai-pr-bot] prepared ${file} and ${test} from MCP data`);
    } finally {
      proc.kill();
    }
  } else {
    // Unknown command → legacy stub
    await writeStub(prompt);
  }
})();